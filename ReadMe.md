# Foss Optimization
## Overview
This project was used to explore optimization methods for battery capacity optimization with the objective of decreasing consumer electricity costs (i.e, providing the optimal residential battery size for cost savings). The Battery_Size_Opt file contains a jupyter notebook file which was used to test different optimization methods and architectures. Through this file, you can see the initial data visualization, processing, and optimization used. It should also lead you through the thought process of the final iteration of optimization methods and alternative methods offered in this project that can provide alternative benefits (such as speed or extended durations). The bat_opt_scipt file is a python file which, with simple user input, can run optimizations on different battery scenarios. The results of these tests are stored by version number in version/optimize_versions – which houses the input parameters and basic output information – as well as results – which houses csv files with the optimal charging outputs. To input different tariffs, users can alter the export_tariff csv and import_tariff csv. More involved descriptions of the code follow below. 

## Quick Start
All requirements can be read from the requirements.txt. After installing these requirements into your enviornment, all code should be runable. Suggested Python version (the one I have run this code on): 3.12.4

## Code Structure
The core optimization logic is stored in three files: 
- *BatteryOptimizer* is a parent class which provides optimization and helper methods to the following two classes. It is psuedo-abstract by defining functions which must be implemented by children classes. Primarily, this provides the optimization interface and SOC calculation. It also houses logic for object construction. 
- *ChargeOptimizer* is a child of BatteryOptimizer. This class optimizes the charge control of a given battery. Although this iteration is not used in bat_opt_script, charge optimizer is what enables the bi-level optimization explored in Battery_Size_Opt. Most interestingly, multiple optimization methods are implemented here, including an attempt at convex (which did not function well) and an L-BFGS-B method using exponential based penalty factors in the objective function. The latter was meant to provide an efficient method of long-term optimization for use in year long bi-level optimization. Although result were achieved for day and week long bi-optimization, they were not as strong as the basic single level optimization. 
- *PriceOptimizer* is a child of BatteryOptimizer. This is a class that optimizes the price of the battery. There are also several optimization methods for price optimizer, including bi-level optimization (with params for changeing the method of inner optimization), local minimization, and global minimization. The best results seemed to come from local minimization.

## Use cases
These optimizations can accurately describe the savings of batteries on residential homes. Not only can this be used for deciding a capacity, but also for finding the cost savings of such energy storage systems. Another use case is to explore the impact of tariff rates on consumer incentives. As we can see by manipulating the tariffs, different schemes allow for totally different incentives which allow or prevent load flattening. 

## Notes
For graphs, one can access a given result_df_version and create the tailored graph that they would like. The reason for not storing graphs as well is that all result dataframes give you the ability to customize a graph which makes sense in the paper or presentation. Also, DO NOT touch the version_num.txt file unless you want to reset all of the previous tests. This versioning system is what prevents each test from overwriting the previous, so there is no need to alter the version_num file unless you are absolutely sure about the modification you are making. 